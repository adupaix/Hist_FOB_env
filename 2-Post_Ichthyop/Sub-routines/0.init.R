
# Load functions used in the following sub-routines:

source(file.path(FUNC_PATH, "1.nc.to.Array.R"))
source(file.path(FUNC_PATH, "1.read.river.data.R"))
source(file.path(FUNC_PATH, "1.subfunctions.R"))
source(file.path(FUNC_PATH,'2.subfunctions.R'))

# Create the name of the simulation from the arguments
sim_name <- generate.sim_name(forcing,
                                input_location,
                                input_method,
                                dist,
                                timestep,
                                dispersion,
                                bouncing)
  
# Create output folder
NEW_OUTPUT_PATH <- file.path(OUTPUT_PATH, sim_name, paste0("ltime",ltime_method,"-",ltime,"_w",weight_method,"_gsize",gsize,
                                                         ifelse(is.null(thr_disch), "_no-thr-disch", paste0("_thr-disch",thr_disch))))
dir.create(NEW_OUTPUT_PATH, recursive = T, showWarnings = F)
  
# Create output files names
logName <- file.path(NEW_OUTPUT_PATH, paste0("Per_",agg.time_scale,"_0.log.txt"))
globalName <- file.path(NEW_OUTPUT_PATH, "1.global_array.rds")
meanAggName <- file.path(NEW_OUTPUT_PATH, paste0("Per_",agg.time_scale,"_2.mean_aggregated_array.rds"))
aggregateName <- file.path(NEW_OUTPUT_PATH, paste0("Per_",agg.time_scale,"_3.aggregated_array.rds"))
plotListName <- file.path(NEW_OUTPUT_PATH, paste0("Per_",agg.time_scale,"_3.maps.rds"))
meanPlotListName <- file.path(NEW_OUTPUT_PATH, paste0("Per_",agg.time_scale,"_2.mean_maps.rds"))
mapName <- file.path(NEW_OUTPUT_PATH, paste0("Per_",agg.time_scale,"_maps.png"))

# Logical to know if files exist (to know if they have to be deleted in case any RESET is true)
filesExist <- file.exists(logName, globalName, meanAggName, aggregateName, plotListName, meanPlotListName, mapName)

# For parallel study:
# On Windows, or if don't want to parralelize, set cores number to 1
if (.Platform$OS.type == "windows" | as.logical(Parallel[1]) == F) {
  nb_cores = 1
} else { #use a fraction of the available cores
  nb_cores = trunc(detectCores() * as.numeric(Parallel[2]))
}

# Do not delete
DoNotDeleteMe <- c("DoNotDeleteMe", ls())

# Delete the output files already created if RESET = T
if (any(RESET) & any(filesExist)){
  
  # if RESET[1] = T, delete the files which exist generated by the two sub_routines 
  if(RESET[1]){
    invisible(file.remove(c(logName, globalName, meanAggName, aggregateName,
                            plotListName, meanPlotListName, mapName)[filesExist] ))
  }
  # if RESET[2] = T, delete the files generated by the second sub_routine which exist
  if (RESET[2]){
    invisible(file.remove(c(plotListName, meanPlotListName, mapName)[filesExist[5:7]]))
  }
}

# Logical to know if files exist (to know if they need to be calculated)
glob_array_exists <- file.exists(globalName)
mean_agg_array_exists <- file.exists(meanAggName)
agg_array_exists <- file.exists(aggregateName)

# Create log file
sink(logName, append = T)
  
cat("#### FROM SIMUALTION RESULTS TO MAPS ####\n=========================================\n Date & Time:",format(Sys.time()),"\n\n")
cat("1. GENERATING ARRAY FROM SIMULATION RESULTS")
cat("\n Execution time :", format(Sys.time()))
cat("\n\n### SIMULATION CHARACTERISTICS")
cat(paste("\n Forcing product :", forcing))
cat(paste("\n Location of input points :", input_location))
cat(paste("\n Method for input points :", input_method))

if (input_method == "kFromCoast"){
  cat(paste0("\n Distance of input from coast : ", dist, "km"))
}
cat(paste0("\n Time step : ", timestep, "h"))
cat(paste0("\n Dispersion coefficient : 10^-", dispersion, " m^2/s^3"))
cat(paste0("\n Bouncing on coast : ", bouncing, "\n\n"))

cat("### ARGUMENTS USED")
cat(paste("\n Life time :", ltime, "days"))
cat(paste("\n Life time method :", ltime_method))
cat(paste("\n Weighting method :", weight_method))
cat(paste("\n Grid cell size :", gsize, "degrees"))
cat(paste("\n Aggregating time scale :", agg.time_scale))
cat(paste("\n Discharge threshold :", ifelse(is.null(thr_disch), "NULL", paste(thr_disch, "m3/s"))))
cat(paste("\n Using parallelization :", as.logical(Parallel[1])))
cat(paste("\n Number of cores used :", ifelse(Parallel[1]==F, 1, trunc(detectCores() * Parallel[2]))))

sink()
  